# Debux
:source-language: clojure
:source-highlighter: coderay
:sectnums:
:imagesdir: ./doc/img
:toc:

*Debux* is a simple but useful library for debugging Clojure and ClojureScript. I wrote
this library to debug my own Clojure(Script) code and to analyze other developer's one.


## Prerequisites

* clojure 1.8.0 or later
* clojurescript 1.9.854 or later


## Installation

To include *debux* in your project, simply add the following to your *project.clj*
dependencies:


[source]
....
[philoskim/debux "0.4.1"]
....


## Change logs

* v0.4.1
** Fixed: The print errors of `dbgn` and `clogn` in ClojureScript are fixed.
** Fixed: The errors of `dbg` and `clog` in ClojureScript are fixed.
** Added: `:loop-type` is added to the macro types.
** Upgraded: `debux.el` is upgraded.

* v0.4.0
** Revived: The old useful features of `dbg` in version 0.2.1 are revived for practicality.

NOTE: You can see _All change logs since v0.3.0_
https://github.com/philoskim/debux/tree/master/doc/change-logs.adoc[here].



## How to use
 
In Clojure, the following line should be included in your file.


[source]
....
(use 'debux.core)
....

In ClojureScript, the following `(:require pass:q[...])` line has to be included in your
file.


[source]
.example/core.cljs
....
(ns example.core
  (:require [debux.cs.core :as d :refer-macros [clog clogn dbg dbgn break]]))
....

{empty} +

[cols="^1m,^1m,^1m,^1m,^1m,^1m", options="header"]
.Debugging API use

|===

|                               | dbg | dbgn | clog | clogn | break

| Clojure REPL                  | O   |   O   |  X   |  X   |   X
| ClojureScript Browser REPL    | O   |   O   |  X   |  X   |   X 
| ClojureScript Browser console | O   |   O   |  O   |  O   |   O

|===

* Legend: `O` (supported), `X` (not supported)

//-

. `dbg`/`dbgn` can be used in Clojure REPL.

. `dbg`/`dbgn` can be used in ClojureScript browser REPL like
  link:https://github.com/tomjakubowski/weasel[weasel] or
  https://github.com/bhauman/lein-figwheel[figwheel].

** Refer to <<browser-repl>> for Browser REPL usage.

. `dbg`/`dbgn` , `clog`/`clogn` and `break` can be used in the browser console window
  like Google DevTool.
+

TIP: I recommend that you should use `clog`/`clogn` instead of `dbg`/`dbgn` in the browser
     console window, because `clog`/`clogn` uses the `console.log` function of browser's
     developer tools to style the form.


## `dbg` examples

NOTE: You can see every example source code of this document in
https://github.com/philoskim/debux/tree/master/example[example] folder.


### Basic usage

NOTE: The features of `clog` are almost the same as those of `dbg`.

The macro `dbg` prints an original form and pretty-prints the evaluated value on the REPL
window. Then it returns the value without interrupting code evaluation.

[source]
....
(* 2 (dbg (+ 10 20)))
; => 60
....

[listing]
.REPL output
----
dbg: (+ 10 20) =>
|   30
----

Sometimes you need to see several forms evaluated. To do so, a literal vector
form can be used like this.

[source]
....
(defn my-fun
  [a {:keys [b c d] :or {d 10 b 20 c 30}} [e f g & h]]
  (dbg [a b c d e f g h]))

(my-fun (take 5 (range)) {:c 50 :d 100} ["a" "b" "c" "d" "e"])
; => [(0 1 2 3 4) 20 50 100 "a" "b" "c" ("d" "e")]
....

[listing]
.REPL output
----

dbg: [a b c d e f g h] =>
|   {:a (0 1 2 3 4),
|    :b 20,
|    :c 50,
|    :d 100,
|    :e "a",
|    :f "b",
|    :g "c",
|    :h ("d" "e")}
----


NOTE: Notice that the printed value is a map, not a vector and the form is prepended with
      colon to differenciate the form from the evaluated value.

Further examples:

[source]
....
(def a 10)
(def b 20)

(dbg [a b [a b] :c])
; => [10 20 [10 20] :c]
....


[listing]
----
dbg: [a b [a b] :c] =>
|   {:a 10, :b 20, :[a b] [10 20], ::c :c}
----



### Debugging thread macro `pass:[->]` or `pass:[->>]`

When debugging the thread-first macro `pass:[->]` or thread-last macro `pass:[->>]`, `dbg`
prints every expression in the thread macros.

This is an example of thread-first macro `pass:[->]`.
  
[source]
....
(dbg (-> "a b c d"
         .toUpperCase
         (.replace "A" "X")
         (.split " ")
         first))
;=> "X"
....

.REPL output
[listing]
----
dbg: (-> "a b c d" .toUpperCase (.replace "A" "X") (.split " ") first) =>
| "a b c d" =>
|   "a b c d"
| .toUpperCase =>
|   "A B C D"
| (.replace "A" "X") =>
|   "X B C D"
| (.split " ") =>
|   ["X", "B", "C", "D"]
| first =>
|   "X"
----
 
Another example.

[source]
....
(def person 
  {:name "Mark Volkmann"
   :address {:street "644 Glen Summit"
             :city "St. Charles"
             :state "Missouri"
             :zip 63304}
   :employer {:name "Object Computing, Inc."
              :address {:street "12140 Woodcrest Dr."
                        :city "Creve Coeur"
                        :state "Missouri"
                        :zip 63141}}})

(dbg (-> person :employer :address :city))
; => "Creve Coeur"
....

.REPL output 
....
dbg: (-> person :employer :address :city) =>
| person =>
|   {:name "Mark Volkmann",
|    :address
|    {:street "644 Glen Summit",
|     :city "St. Charles",
|     :state "Missouri",
|     :zip 63304},
|    :employer
|    {:name "Object Computing, Inc.",
|     :address
|     {:street "12140 Woodcrest Dr.",
|      :city "Creve Coeur",
|      :state "Missouri",
|      :zip 63141}}}
| :employer =>
|   {:name "Object Computing, Inc.",
|    :address
|    {:street "12140 Woodcrest Dr.",
|     :city "Creve Coeur",
|     :state "Missouri",
|     :zip 63141}}
| :address =>
|   {:street "12140 Woodcrest Dr.",
|    :city "Creve Coeur",
|    :state "Missouri",
|    :zip 63141}
| :city =>
|   "Creve Coeur"
....
   
This is an example of thread-last macro `pass:[->>]`.
  
[source]
....
(def c 5)

(dbg (->> c (+ 3) (/ 2) (- 1)))
; => 3/4
....
  
.REPL output
....
dbg: (->> c (+ 3) (/ 2) (- 1)) =>
| c =>
|   5
| (+ 3) =>
|   8
| (/ 2) =>
|   1/4
| (- 1) =>
|   3/4
....

If you want to debug one of the expressions in the thread macro `pass:[->]` or
`pass:[->>]`, don't do it like this.

[source]
....
(-> {:a [1 2]}
    (dbg (get :a))
    (conj 3))
; => java.lang.IllegalArgumentException
;    Don't know how to create ISeq from: java.lang.Long
....

You will have some exception. Instead, do it like this.

[source]
....
(-> {:a [1 2]}
    (get :a)
    dbg
    (conj 3))
; => [1 2 3]
....

.REPL output
....
dbg: (get {:a [1 2]} :a) =>
|   [1 2]
....

Another example.
  
[source]
....
(->> [-1 0 1 2]
     (filter pos?)
     (map inc)
     dbg
     (map str))
; => ("2" "3")
....
  
.REPL output
....
dbg: (map inc (filter pos? [-1 0 1 2])) =>
|   (2 3)
....

  
### Debugging `let` or `comp` form

When debugging `let` form,

[source]
....
(dbg (let [a (take 5 (range))
           {:keys [b c d] :or {d 10 b 20 c 30}} {:c 50 :d 100}
           [e f g & h] ["a" "b" "c" "d" "e"]]
        [a b c d e f g h]))
; => [(0 1 2 3 4) 20 50 100 "a" "b" "c" ("d" "e")]
....

each binding will be printed like this.
  
.REPL output 
....
dbg: (let [a (take 5 (range)) {:keys [b c d], :or {d 10, b 20, c 30}} {:c 5 ... =>
| a =>
|   (0 1 2 3 4)
| {:keys [b c d], :or {d 10, b 20, c 30}} =>
|   {:keys [20 50 100], :or {100 10, 20 20, 50 30}}
| [e f g & h] =>
|   ["a" "b" "c" & ("d" "e")]
....

When debugging `comp` form,

[source]
....
(def c (dbg (comp inc inc +)))

(c 10 20)
; => 32
....
the result of each function will be printed like this.
  
.REPL output 
....
dbg: (comp inc inc +) =>
| + =>
|   30
| inc =>
|   31
| inc =>
|   32
....



## `dbgn` examples

NOTE: The features of `clogn` are almost the same as those of `dbgn`.

The macro `dbgn` is for Clojure/CloujureScript REPL and the macro `clogn` is for
ClojureScript browser console only. The appended *n* to these two macro names means
**N**ested forms. You can debug every nested form without interrupting code
evaluations. This feature is very useful, especially when you analyze other developer's
source code.


### Simple example

[source]
....
(dbgn (defn foo [a b & [c]]
        (if c
          (* a b c)
          (* a b 100))))

(foo 2 3)
; => 600

(foo 2 3 10)
; => 60
....

[listing]
.REPL output
----
dbgn: (defn foo [a b & [c]] (if c (* a b c) (* a b 100))) =>

| c =>
|   nil
| a =>
|   2
| b =>
|   3
| (* a b 100) =>
|   600
| (if c (* a b c) (* a b 100)) =>
|   600

| c =>
|   10
| a =>
|   2
| b =>
|   3
| c =>
|   10
| (* a b c) =>
|   60
| (if c (* a b c) (* a b 100)) =>
|   60
----


### Detailed examples

* `dbgn`/`clogn` don't have any problem in handling functions.

* `dbgn`/`clogn`, however, can have some problem in case of macros and special forms.

** Some macros such as `when` don't have any problem when used in `dbgn`/`clogn`.

** Other macros such as `defn` which has a binding vector can have problem because they
   have binding symbols which must not be evaluated in `dbgn`/`clogn` macros. In case of
   special forms and those macros in `clojure.core` namespace, `degn`/`clogn` can handle
   them appropriately.

** In some cases, Clojure developers can write their own macros which `dbgn`/`clogn` cannot
   handle appporiately. So I categorized those macros in `clojure.core` namespace as the
   following table and you can register your own macros according to the macro types in
   the table. I will explain it in <<register-macros>>.


[#macro-type-table, cols="^3m,<7m", options="header"]
.Categorized 16 types of macros in `dbgn`/`clogn`
|===

| Macro types | Macros in `clojure.core` and special forms
| :def-type   | def defonce
| :defn-type  | defn defn-
| :fn-type    | fn fn*
| :let-type   | let binding dotimes if-let if-some when-first when-let when-some
                with-in-str with-local-vars with-open with-out-str with-redefs
| :letfn-type | letfn
| :loop-type  | loop
| :for-type   | for doseq
| :case-type  | case
| :skip-arg-1-type     | set! with-precision
| :skip-arg-2-type     | pass:q[as->]
| :skip-arg-1-2-type   | 
| :skip-arg-1-3-type   | defmethod
| :skip-arg-2-3-type   | amap areduce
| :skip-form-itself-type  | catch comment declare definline definterface defmacro defmulti
                            defprotocol defrecord defstruct deftype extend-protocol
                            extend-type finally gen-class gen-interface import memfn new
                            ns proxy proxy-super quote refer-clojure reify sync var throw
| :expand-type | pass:q[.. -> ->> doto cond-> cond->> condp import some-> some->>]
| :dot-type    | .

|===


#### `:def-type` example

This type of macros have the first argument which must not be evaluated and can have
optional `doc-string` argument.

[source]
....
(dbgn (def my-function "my-function doc string"
        (fn [x] (* x x x))))

(my-function 10)
; => 1000
....


[listing]
.REPL output
----
dbgn: (def my-function "my-function doc string" (fn [x] (* x x x))) =>
| (fn [x] (* x x x)) =>
|   #function[example.core/eval24554/result--24229--auto----24555]
| (def my-function "my-function doc string" (fn [x] (* x x x))) =>
|   #'example.core/my-function

| x =>
|   10
| x =>
|   10
| x =>
|   10
| (* x x x) =>
|   1000
----


#### `:defn-type` example

This type of macros have the binding vector argument which must not be evaluated and can
have optional `doc-string`, `attr-map`, or `prepost-map` arguments.

[source]
....
(dbgn (defn add
        "add doc string"
        [a b]
        (+ a b)))

(add 10 20)
; => 30
....

[listing]
.REPL output
----
dbgn: (defn add "add doc-string" [a b] (+ a b)) =>

| a =>
|   10
| b =>
|   20
| (+ a b) =>
|   30
----

{empty} +


You can debug multiple-arity functions as well.

[source]
....
(dbgn (defn my-add
        "my-add doc string"
        ([] 0)
        ([a] a)
        ([a b] (+ a b))
        ([a b & more] (apply + a b more))))

; The function body in this case doesn't have any symbol to evaluate,
; so no output will be printed. 
(my-add)
; => 0

(my-add 10)
; => 10

(my-add 10 20)
; => 30 

(my-add 10 20 30 40)
; => 100
....

[listing]
.REPL output
----
dbgn: (defn my-add "my-add doc string" ([] 0) ([a] a) ([a b] (+ a b)) ([a b  ... =>

| a =>
|   10

| a =>
|   10
| b =>
|   20
| (+ a b) =>
|   30

| + =>
|   #function[clojure.core/+]
| a =>
|   10
| b =>
|   20
| more =>
|   (30 40)
| (apply + a b more) =>
|   100
----

{empty} +

You can have multiple `dbgn`/``clogn``s.

[source]
....
(dbgn (defn calc1 [a1 a2] (+ a1 a2)))
(dbgn (defn calc2 [s1 s2] (- 100 (calc1 s1 s2))))
(dbgn (defn calc3 [m1 m2] (* 10 (calc2 m1 m2))))

(calc3 2 5)
; => 760
....


[listing]
.REPL output
----
dbgn: (defn calc1 [a1 a2] (+ a1 a2)) =>

dbgn: (defn calc2 [s1 s2] (- 100 (calc1 s1 s2))) =>

dbgn: (defn calc3 [m1 m2] (* 10 (calc2 m1 m2))) =>

| m1 =>
|   2
| m2 =>
|   5
 
|| s1 =>
||   2
|| s2 =>
||   5
 
||| a1 =>
|||   2
||| a2 =>
|||   5
||| (+ a1 a2) =>
|||   7
|| (calc1 s1 s2) =>
||   7
|| (- 100 (calc1 s1 s2)) =>
||   93
| (calc2 m1 m2) =>
|   93
| (* 10 (calc2 m1 m2)) =>
|   930
----


#### `:fn-type` example

This type of macros have the binding vector argument which must not be evaluated and can
have optional function name. So it is a little different from `:defn-type` macros.

[source]
....
(dbgn (reduce (fn [acc i] (+ acc i)) 0 [1 5 9]))
; => 15
....

[listing]
.REPL output
----
dbgn: (reduce (fn [acc i] (+ acc i)) 0 [1 5 9]) =>
| (fn [acc i] (+ acc i)) =>
|   #function[example.core/eval25034/result--24229--auto----25035]
| [1 5 9] =>
|   [1 5 9]
| acc =>
|   0
| i =>
|   1
| (+ acc i) =>
|   1
| acc =>
|   1
| i =>
|   5
| (+ acc i) =>
|   6
| acc =>
|   6
| i =>
|   9
| (+ acc i) =>
|   15
| (reduce (fn [acc i] (+ acc i)) 0 [1 5 9]) =>
|   15
----


{empty} +


[source]
.Another example
....
(dbgn (map #(* % 10) [1 5 9]))
; => (10 50 90)
....

[listing]
.REPL output
----
dbgn: (map (fn* [p1__25079#] (* p1__25079# 10)) [1 5 9]) =>
| (fn* [p1__25079#] (* p1__25079# 10)) =>
|   #function[example.core/eval25080/result--24229--auto----25081]
| [1 5 9] =>
|   [1 5 9]
| (map (fn* [p1__25079#] (* p1__25079# 10)) [1 5 9]) =>
|   | p1__25079# =>
|   |   1
|   | (* p1__25079# 10) =>
|   |   10
|   | p1__25079# =>
|   |   5
|   | (* p1__25079# 10) =>
|   |   50
|   | p1__25079# =>
|   |   9
|   | (* p1__25079# 10) =>
|   |   90
|   (10 50 90)
----
 


#### `:let-type` example

This type of macros have the binding vector argument which must not be evaluated.

[source]
....
(dbgn (let [a (+ 1 2)
            [b c] [(+ a 10) (* a 2)]] 
         (- (+ a b) c)))
; => 10
....


[listing]
.REPL output
----
dbgn: (let [a (+ 1 2) [b c] [(+ a 10) (* a 2)]] (- (+ a b) c)) =>
| (+ 1 2) =>
|   3
| a =>
|   3
| (+ a 10) =>
|   13
| a =>
|   3
| (* a 2) =>
|   6
| [(+ a 10) (* a 2)] =>
|   [13 6]
| a =>
|   3
| b =>
|   13
| (+ a b) =>
|   16
| c =>
|   6
| (- (+ a b) c) =>
|   10
| (let [a (+ 1 2) [b c] [(+ a 10) (* a 2)]] (- (+ a b) c)) =>
|   10
----


#### `:letfn-type` example

This type of macro has the special binding vector syntax which is a bit different from
`:fn-type`.

[source]
....
(dbgn (letfn [(twice [x]
                (* x 2))
              (six-times [y]
                (* (twice y) 3))]
        (six-times 15)))
; => 90
....


[listing]
.REPL output
----
dbgn: (letfn [(twice [x] (* x 2)) (six-times [y] (* (twice y) 3))] (six-time ... =>
| y =>
|   15
| x =>
|   15
| (* x 2) =>
|   30
| (twice y) =>
|   30
| (* (twice y) 3) =>
|   90
| (six-times 15) =>
|   90
| (letfn [(twice [x] (* x 2)) (six-times [y] (* (twice y) 3))] (six-time ... =>
|   90
----

#### `:loop-type` example

This type of macro is similiar to `:let-type` but has a significant difference because the `recur` has to be placed at the tail positon with the `loop` form. So it needs a special handling in the implementation of `dbgn`/`clogn`. Refer to <<recur-support>> for details.


#### `:for-type` example

This type of macros have a little different syntax from `:let-type` macros, because it
can have `:let`, `:when`, or `:while` clause.
 
[source]
....
(dbgn (for [x [0 1 2 3 4 5]
            :let [y (* x 3)]
            :when (even? y)]
        y))
; => (0 6 12)
....


[listing]
.REPL output
----
dbgn: (for [x [0 1 2 3 4 5] :let [y (* x 3)] :when (even? y)] y) =>
| [0 1 2 3 4 5] =>
|   [0 1 2 3 4 5]
| (for [x [0 1 2 3 4 5] :let [y (* x 3)] :when (even? y)] y) =>
|   | x =>
|   |   0
|   | (* x 3) =>
|   |   0
|   | y =>
|   |   0
|   | (even? y) =>
|   |   true
|   | y =>
|   |   0
|   | x =>
|   |   1
|   | (* x 3) =>
|   |   3
|   | y =>
|   |   3
|   | (even? y) =>
|   |   false
|   | x =>
|   |   2
|   | (* x 3) =>
|   |   6
|   | y =>
|   |   6
|   | (even? y) =>
|   |   true
|   | y =>
|   |   6
|   | x =>
|   |   3
|   | (* x 3) =>
|   |   9
|   | y =>
|   |   9
|   | (even? y) =>
|   |   false
|   | x =>
|   |   4
|   | (* x 3) =>
|   |   12
|   | y =>
|   |   12
|   | (even? y) =>
|   |   true
|   | y =>
|   |   12
|   | x =>
|   |   5
|   | (* x 3) =>
|   |   15
|   | y =>
|   |   15
|   | (even? y) =>
|   |   false
|   (0 6 12)
----


#### `:case-type` example

This type of macro has the special syntax. Refer to
https://clojuredocs.org/clojure.core/case[here] about details.

[source]
....
(dbgn (let [mystr "hello"]
        (case mystr
          "" 0
          "hello" (count mystr))))
; => 5
....


[listing]
.REPL output
----
dbgn: (let [mystr "hello"] (case mystr  0 hello (count mystr))) =>
| mystr =>
|   "hello"
| mystr =>
|   "hello"
| (count mystr) =>
|   5
| (case mystr "" 0 "hello" (count mystr)) =>
|   5
| (let [mystr "hello"] (case mystr "" 0 "hello" (count mystr))) =>
|   5
----

{empty} +


[source]
.Another example
....
(dbgn (case 'a
        (x y z) "x, y, or z"
        "default"))
; => "default"
....

[listing]
.REPL output
----
dbgn: (case (quote a) (x y z) "x, y, or z" "default") =>
| (case (quote a) (x y z) "x, y, or z" "default") =>
|   "default"
----


#### `:skip-arg-1-type` example

This type of macros have the first argument which must not be evaluated. So `dbgn`/`clogn`
internally skips the evaluation of this argument.

[source]
....
(dbgn (with-precision 10 (/ 1M 6)))
; => 0.1666666667M
....


[listing]
.REPL output
----
dbgn: (with-precision 10 (/ 1M 6)) =>
| (/ 1M 6) =>
|   0.1666666667M
| (with-precision 10 (/ 1M 6)) =>
|   0.1666666667M
----

#### `:skip-arg-2-type` example

This type of macros have the second argument which must not be evaluated. So `dbgn`/`clogn`
internally skips the evaluation of this argument.

[source]
....
(dbgn (as-> 0 n
        (inc n)
        (inc n)))
; => 2
....


[listing]
.REPL output
----
dbgn: (as-> 0 n (inc n) (inc n)) =>
| n =>
|   0
| (inc n) =>
|   1
| n =>
|   1
| (inc n) =>
|   2
| (as-> 0 n (inc n) (inc n)) =>
|   2
----


#### `:skip-arg-1-2-type` example

This type of macros have the first and second arguments which must not be evaluated. So
`dbgn`/`clogn` internally skips the evaluation of those arguments. However, I can't find this
type of macros in `clojure.core` namespace but add this type for completeness and the
future possibilities of this type of macros.


#### `:skip-arg-1-3-type` example

This type of macros have the first and third arguments which must not be evaluated. So
`dbgn`/`clogn` internally skips the evaluation of those arguments.

[source]
....
(defmulti greeting
  (fn [x] (:language x)))

(dbgn (defmethod greeting :english [map]
        (str "English greeting: " (:greeting map))))

(dbgn (defmethod greeting :french [map]
        (str "French greeting: " (:greeting map))))

(def english-map {:language :english :greeting "Hello!"})
(def french-map {:language :french :greeting "Bonjour!"})

(greeting english-map)
(greeting french-map)
....


[listing]
.REPL output
----
dbgn: (defmethod greeting :english [map] (str "English greeting: " (:greetin ... =>
| (defmethod greeting :english [map] (str "English greeting: " (:greeting map))) =>
|   #multifn[greeting 0x1c28c1cc]

dbgn: (defmethod greeting :french [map] (str "French greeting: " (:greeting  ... =>
| (defmethod greeting :french [map] (str "English greeting: " (:greeting map))) =>
|   #multifn[greeting 0x1c28c1cc]

| map =>
|   {:language :english, :greeting "Hello!"}
| (:greeting map) =>
|   "Hello!"
| (str "English greeting: " (:greeting map)) =>
|   "English greeting: Hello!"

| map =>
|   {:language :french, :greeting "Bonjour!"}
| (:greeting map) =>
|   "Bonjour!"
| (str "French greeting: " (:greeting map)) =>
|   "French greeting: Bonjour!"
----


#### `:skip-arg-2-3-type` example

This type of macros have the second and third arguments which must not be evaluated. So
`dbgn`/`clogn` internally skips the evaluation of those arguments.


[source]
....
(let [xs (float-array [1 2 3])]
  (dbgn (areduce xs i ret (float 0)
                 (+ ret (aget xs i)))))
; => 6.0
....


[listing]
.REPL output
----
dbgn: (areduce xs i ret (float 0) (+ ret (aget xs i))) =>
| xs =>
|   [1.0, 2.0, 3.0]
| (float 0) =>
|   0.0
| ret =>
|   0.0
| xs =>
|   [1.0, 2.0, 3.0]
| i =>
|   0
| (aget xs i) =>
|   1.0
| (+ ret (aget xs i)) =>
|   1.0
| ret =>
|   1.0
| xs =>
|   [1.0, 2.0, 3.0]
| i =>
|   1
| (aget xs i) =>
|   2.0
| (+ ret (aget xs i)) =>
|   3.0
| ret =>
|   3.0
| xs =>
|   [1.0, 2.0, 3.0]
| i =>
|   2
| (aget xs i) =>
|   3.0
| (+ ret (aget xs i)) =>
|   6.0
| (areduce xs i ret (float 0) (+ ret (aget xs i))) =>
|   6.0
----


#### `:skip-form-itself-type` example

This type of macros have too complex to parse, so `dbgn`/`clogn` skips the form itself and does
nothing.
  

#### `:expand-type` example

This type of macros will be expanded and then the output will be printed.

[source]
....
(dbgn (-> "a b c d" 
          .toUpperCase 
          (.replace "A" "X") 
          (.split " ") 
          first))
; => "X"
....

[listing]
.REPL output
----
dbgn: (-> "a b c d" .toUpperCase (.replace "A" "X") (.split " ") first) =>
| (.toUpperCase "a b c d") =>
|   "A B C D"
| (.replace (.toUpperCase "a b c d") "A" "X") =>
|   "X B C D"
| (.split (.replace (.toUpperCase "a b c d") "A" "X") " ") =>
|   ["X", "B", "C", "D"]
| (first (.split (.replace (.toUpperCase "a b c d") "A" "X") " ")) =>
|   "X"
----


{empty} +


[source]
.Another example
....
(dbgn (.. "fooBAR"  toLowerCase  (contains "ooba")))
; => true
....


[listing]
.REPL output
----
dbgn: (.. "fooBAR" toLowerCase (contains "ooba")) =>
| (. "fooBAR" toLowerCase) =>
|   "foobar"
| (. (. "fooBAR" toLowerCase) (contains "ooba")) =>
|   true
----

{empty} +

[source]
.Yet another example
....
(let [x 1 y 2]
  (dbgn (cond-> []
          (odd? x) (conj "x is odd")
          (zero? (rem y 3)) (conj "y is divisible by 3")
          (even? y) (conj "y is even"))))
; => ["x is odd" "y is even"]
....

[listing]
.REPL output
----
dbgn: (cond-> [] (odd? x) (conj "x is odd") (zero? (rem y 3)) (conj "y is di ... =>
| [] =>
|   []
| x =>
|   1
| (odd? x) =>
|   true
| G__25146 =>
|   []
| (conj G__25146 "x is odd") =>
|   ["x is odd"]
| (if (odd? x) (conj G__25146 "x is odd") G__25146) =>
|   ["x is odd"]
| y =>
|   2
| (rem y 3) =>
|   2
| (zero? (rem y 3)) =>
|   false
| G__25146 =>
|   ["x is odd"]
| (if (zero? (rem y 3)) (conj G__25146 "y is divisible by 3") G__25146) =>
|   ["x is odd"]
| y =>
|   2
| (even? y) =>
|   true
| G__25146 =>
|   ["x is odd"]
| (conj G__25146 "y is even") =>
|   ["x is odd" "y is even"]
| (if (even? y) (conj G__25146 "y is even") G__25146) =>
|   ["x is odd" "y is even"]
| (clojure.core/let [G__28483 [] G__28483 (if (odd? x) (conj G__28483 "x ... =>
|   ["x is odd" "y is even"]
----


#### `:dot-type` example

[source]
....
(dbgn (. (java.util.Date.) getMonth))
; => 5
....


[listing]
.REPL output
----
dbgn: (. (java.util.Date.) getMonth) =>
| (java.util.Date.) =>
|   #inst "2017-06-27T08:04:46.480-00:00"
| (. (java.util.Date.) getMonth) =>
|   5
----


[#recur-support]
### Limited support for the form including `recur`

[cols="^1m,^1m,^1m", options="header"]
.The forms including `recur`
|===

|                        | dbgn  | clogn
| loop ~ recur           |   O   |   X   
| defn/defn-/fn ~ recur  |  △   |   X    

|===


#### `loop` ~ `recur`

You can see the evaluated results of the form which incldues `loop` ~ `recur` by using
`dbgn` in Clojure and ClojureScript.

[source]
....
(dbgn (loop [acc 1 n 3]
        (if (zero? n)
          acc
          (recur (* acc n) (dec n)))))
; => 6
....

.REPL output
[listing]
----
dbgn: (loop [acc 1 n 3] (if (zero? n) acc (recur (* acc n) (dec n)))) =>
| n =>
|   3
| (zero? n) =>
|   false
| acc =>
|   1
| n =>
|   3
| (* acc n) =>
|   3
| n =>
|   3
| (dec n) =>
|   2
| n =>
|   2
| (zero? n) =>
|   false
| acc =>
|   3
| n =>
|   2
| (* acc n) =>
|   6
| n =>
|   2
| (dec n) =>
|   1
| n =>
|   1
| (zero? n) =>
|   false
| acc =>
|   6
| n =>
|   1
| (* acc n) =>
|   6
| n =>
|   1
| (dec n) =>
|   0
| n =>
|   0
| (zero? n) =>
|   true
| acc =>
|   6
| (loop [acc 1 n 3] (if (zero? n) acc (recur (* acc n) (dec n)))) =>
|   6
----

{empty} +

[source]
.Another example
....
(dbgn (defn fact [num]
        (loop [acc 1 n num]
          (if (zero? n)
            acc
            (recur (* acc n) (dec n))))))

(fact 3)
....


[listing]
.REPL output
----
dbgn: (defn fact [num] (loop [acc 1 n num] (if (zero? n) acc (recur (* acc n ... =>

| num =>
|   3
| n =>
|   3
| (zero? n) =>
|   false
| acc =>
|   1
| n =>
|   3
| (* acc n) =>
|   3
| n =>
|   3
| (dec n) =>
|   2
| n =>
|   2
| (zero? n) =>
|   false
| acc =>
|   3
| n =>
|   2
| (* acc n) =>
|   6
| n =>
|   2
| (dec n) =>
|   1
| n =>
|   1
| (zero? n) =>
|   false
| acc =>
|   6
| n =>
|   1
| (* acc n) =>
|   6
| n =>
|   1
| (dec n) =>
|   0
| n =>
|   0
| (zero? n) =>
|   true
| acc =>
|   6
| (loop [acc 1 n num] (if (zero? n) acc (recur (* acc n) (dec n)))) =>
|   6
----



#### `defn`/`defn-`/`fn` ~ `recur` without `loop`

IMPORTANT: If you use `dbgn` in `defn`/`defn-`/`fn` ~ `recur` form without `loop`, you
will have the following exception. I am sorry about it, but this is inevitable due to the
implementation restriction.


[source]
....
(dbgn (defn factorial [acc n]
        (if (zero? n)
          acc
          (recur (* acc n) (dec n)))))
....

.REPL output
[listing]
----
1. Caused by java.lang.UnsupportedOperationException
   Cannot recur across try
----

{empty} +

TIP: However, if you *temporarily* replace `recur` with `function name` itself, you can
debug the form as follows. *Be careful* not to forget to recover `function name` itself to
`recur` after debugging.

[source]
....
(dbgn (defn factorial [acc n]
        (if (zero? n)
          acc
          (factorial (* acc n) (dec n)))))

(factorial 1 3)
....

.REPL output
[listing]
----
dbgn: (defn factorial [acc n] (if (zero? n) acc (factorial (* acc n) (dec n) ... =>

| n =>
|   3
| (zero? n) =>
|   false
| acc =>
|   1
| n =>
|   3
| (* acc n) =>
|   3
| n =>
|   3
| (dec n) =>
|   2
 
|| n =>
||   2
|| (zero? n) =>
||   false
|| acc =>
||   3
|| n =>
||   2
|| (* acc n) =>
||   6
|| n =>
||   2
|| (dec n) =>
||   1
 
||| n =>
|||   1
||| (zero? n) =>
|||   false
||| acc =>
|||   6
||| n =>
|||   1
||| (* acc n) =>
|||   6
||| n =>
|||   1
||| (dec n) =>
|||   0
 
|||| n =>
||||   0
|||| (zero? n) =>
||||   true
|||| acc =>
||||   6
|||| (if (zero? n) acc (factorial (* acc n) (dec n))) =>
||||   6
||| (factorial (* acc n) (dec n)) =>
|||   6
||| (if (zero? n) acc (factorial (* acc n) (dec n))) =>
|||   6
|| (factorial (* acc n) (dec n)) =>
||   6
|| (if (zero? n) acc (factorial (* acc n) (dec n))) =>
||   6
| (factorial (* acc n) (dec n)) =>
|   6
| (if (zero? n) acc (factorial (* acc n) (dec n))) =>
|   6
----


[#register-macros]
### How to register your own macros in using `dbgn`/`clogn`

* If you have some error when analyzing some source code using `dbgn`/`clogn`, first
  of all, you have to figure out what kind of macro (refer to <<macro-type-table>>) caused
  the error and then register the macro by using `register-macros!`.

* You can see the registered macros by using `show-macros`.


[source]
.API format
....
(register-macros! macro-type macros)

(show-macros)
(show-macros macro-type)
....

#### Clojure example

[source]
.example/core.clj
....
(ns example.core)

(use 'debux.core)

(defmacro my-let [bindings & body]
  `(let ~bindings ~@body))

;; Registering your own macro
(register-macros! :let-type [my-let])

(dbg (show-macros :let-type))
(dbg (show-macros))

(dbgn (my-let [a 10 b (+ a 10)] (+ a b)))
....


[listing]
.REPL output
----
bg: (show-macros :let-type) =>
|   {:let-type
|    #{clojure.core/when-let example.dbgn/my-let clojure.core/let
|      clojure.core/with-local-vars clojure.core/if-let
|      clojure.core/when-some clojure.core/dotimes clojure.core/with-open
|      clojure.core/if-some clojure.core/with-redefs clojure.core/binding
|      clojure.core/with-in-str clojure.core/with-out-str clojure.core/loop
|      clojure.core/when-first}}

dbg: (show-macros) =>
|   {:fn-type #{clojure.core/fn fn*},
|    :skip-form-itself-type
|    #{clojure.core/proxy-super clojure.core/defmacro
|      clojure.core/definterface clojure.core/sync clojure.core/defrecord
|      clojure.core/declare clojure.core/deftype clojure.core/comment
|      finally clojure.core/gen-class clojure.core/refer-clojure
|      clojure.core/memfn clojure.core/extend-type new
|      clojure.core/definline clojure.core/defstruct clojure.core/defmulti
|      clojure.core/ns clojure.core/proxy clojure.core/extend-protocol var
|      quote clojure.core/reify catch clojure.core/gen-interface
|      clojure.core/import clojure.core/defprotocol throw},
|    :case-type #{clojure.core/case},
|    :skip-arg-2-3-type #{clojure.core/areduce clojure.core/amap},
|    :skip-arg-1-type #{clojure.core/with-precision set!},
|    :let-type
|    #{clojure.core/when-let example.dbgn/my-let clojure.core/let
|      clojure.core/with-local-vars clojure.core/if-let
|      clojure.core/when-some clojure.core/dotimes clojure.core/with-open
|      clojure.core/if-some clojure.core/with-redefs clojure.core/binding
|      clojure.core/with-in-str clojure.core/with-out-str clojure.core/loop
|      clojure.core/when-first},
|    :skip-arg-2-type #{clojure.core/as->},
|    :defn-type #{clojure.core/defn clojure.core/defn-},
|    :loop-type #{clojure.core/loop},
|    :for-type #{clojure.core/for clojure.core/doseq},
|    :def-type #{clojure.core/defonce def},
|    :letfn-type #{clojure.core/letfn},
|    :dot-type #{.},
|    :skip-arg-1-2-type #{},
|    :expand-type
|    #{clojure.core/doto clojure.core/->> clojure.core/some->>
|      clojure.core/.. clojure.core/-> clojure.core/some->
|      clojure.core/cond-> clojure.core/condp clojure.core/import
|      clojure.core/cond->>},
|    :skip-arg-1-3-type #{clojure.core/defmethod}}

dbgn: (my-let [a 10 b (+ a 10)] (+ a b)) =>
| a =>
|   10
| (+ a 10) =>
|   20
| a =>
|   10
| b =>
|   20
| (+ a b) =>
|   30
| (my-let [a 10 b (+ a 10)] (+ a b)) =>
|   30
----


#### ClojureScript example

[source]
.example/macro.clj
....
(ns example.macro)

(defmacro my-let [bindings & body]
  `(let ~bindings ~@body))
....


[source]
.example/core.cljs
....
(ns example.core
  (:require [debux.cs.core :as d :refer-macros [clog clogn dbg dbgn break]])
  (:require-macros [example.macro :refer [my-let]]))

;; Registering your own macro
(d/register-macros! :let-type [my-let])

(dbg (d/show-macros :let-type))
(dbg (d/show-macros))

(clogn (my-let [a 10 b (+ a 10)] (+ a b)))
....


[listing]
.Output
----
dbg: (d/show-macros :let-type) =>
|   {:let-type
|    #{example.macro/my-let cljs.core/with-redefs cljs.core/binding
|      cljs.core/when-first
|      cljs.core/if-some
|      cljs.core/let
|      cljs.core/with-out-str
|      cljs.core/loop
|      cljs.core/when-let
|      cljs.core/when-some cljs.core/if-let cljs.core/dotimes}}

dbg: (d/show-macros) =>
|   {:fn-type #{fn* cljs.core/fn},
|    :skip-form-itself-type
|    #{cljs.core/defmulti finally cljs.core/defprotocol
|      cljs.core/extend-protocol
|      new
|      cljs.core/import
|      cljs.core/defrecord
|      cljs.core/declare
|      cljs.core/reify
|      cljs.core/deftype
|      cljs.core/comment
|      cljs.core/memfn
|      var
|      quote
|      cljs.core/refer-clojure
|      catch
|      cljs.core/extend-type
|      throw
|      cljs.core/defmacro},
|    :case-type #{cljs.core/case},
|    :skip-arg-2-3-type #{cljs.core/amap cljs.core/areduce},
|    :skip-arg-1-type #{set!},
|    :let-type
|    #{example.macro/my-let cljs.core/with-redefs cljs.core/binding
|      cljs.core/when-first
|      cljs.core/if-some
|      cljs.core/let
|      cljs.core/with-out-str
|      cljs.core/loop
|      cljs.core/when-let
|      cljs.core/when-some
|      cljs.core/if-let
|      cljs.core/dotimes},
|    :skip-arg-2-type #{cljs.core/as->},
|    :defn-type #{cljs.core/defn- cljs.core/defn},
|    :loop-type #{cljs.core/loop},
|    :for-type #{cljs.core/doseq cljs.core/for},
|    :def-type #{cljs.core/defonce def},
|    :letfn-type #{cljs.core/letfn},
|    :dot-type #{.},
|    :skip-arg-1-2-type #{},
|    :expand-type
|    #{cljs.core/.. cljs.core/some-> cljs.core/-> cljs.core/cond->>
|      cljs.core/import
|      cljs.core/doto
|      cljs.core/condp
|      cljs.core/cond->
|      cljs.core/some->>
|      cljs.core/->>}, 
|    :skip-arg-1-3-type #{cljs.core/defmethod}}
----

image::register-macros.png[title="register-macros! example", width=600]



## Various options

* The various options can be added and combined in any order after the form.

[cols="^1m,^1m,^1m,^1m,^1m,^1m", options="header"]
.*debux* macro options
|===

| Options | dbg | dbgn | clog | clogn | break

| string  | O   |   O   |  O   |  O   |   O
| number  | O   |   O   |  O   |  O   |   X 
| :if     | O   |   O   |  O   |  O   |   O
| :style  | X   |   X   |  O   |  O   |   X
| :once   | X   |   X   |  O   |  X   |   X
| :js     | X   |   X   |  O   |  X   |   X

|===

* Legend: `O` (supported), `X` (not supported)


### String option

You can add your own message in a string and it will be printed between less-than and
more-than signs like this.


[source]
....
(dbg (repeat 5 "x") "5 times repeat"))
; => ("x" "x" "x" "x" "x")
....
  
.REPL output
....
dbg: (repeat 5 "x")   <5 times repeat> =>
|   ("x" "x" "x" "x" "x")
....


### Number option

If you don't specify a number after the form returning the `seq` data type, *debux* macros
will print and return the default 100 items.

IMPORTANT: The number option doesn't apply to vectors, maps or sets.
 

[source]
....
(dbg (range 200))
; => (0 1 2 ... 99)
....

.REPL output
[listing]
----
dbg: (range 200) =>
|   (0 1 2  ... 99)
----

So, if you want to print less or more than default 100 items, specify the number
explicitly like this.

....
(dbg (range 200) 200)
; => (0 1 2 ... 199)
....

.REPL output
[listing]
----
dbg: (range 200) =>
|   (0 1 2 ... 199)
----

The same rule applies in case of evaluating an *infinite lazy-seq*. If you omit the number
in evaluating an *infinite lazy-seq*, in the same manner it will print and return default
100 elements to prevent `OutOfMemoryError`.

[source]
....
(dbg (range))
; => (0 1 2 ... 99)
....
  
.REPL output
....
dbg: (range) =>
|   (0 1 2 ... 99)
....


### `:if` option

You can set `:if` option like this.

[source]
....
(doseq [i (range 10)]
  (dbg i :if (even? i)))
; => (0 1 2 3 4 5 6 7 8 9)
....

.REPL output
....
dbg: i =>
|   0

dbg: i =>
|   2

dbg: i =>
|   4

dbg: i =>
|   6

dbg: i =>
|   8
....


### `:style` option (CSS Styling)

The following is the example of using `clog` and `clogn` in Google Chrome
browser.
 
[source]
.example/core.cljs
....
(ns example.core
  (:require [debux.cs.core :as d :refer-macros [clog clogn dbg dbgn break]]))

(clog (repeat 5 "x") "5 times repeat")
(clogn (repeat 5 (repeat 5 "x")) "25 times repeat")
....

image::clog-1.png[title="clog and clogn example", width=550]


#### Predefined style keywords

You can style the form, using the following predefined keywords.

[cols="^,^", options="header", width="30"]
|===

| keyword | abbreviation
| :style  | :s
| :error  | :e
| :warn   | :w
| :info   | :i
| :debug  | :d

|===

....
(clog (+ 10 20) :style :error "error style")
(clog (+ 10 20) :style :warn "warn style")
(clog (+ 10 20) :style :info "info style")
(clog (+ 10 20) :style :debug "debug style")
(clog (+ 10 20) "debug style is default")
....
  
Or in brief

....  
(clog (+ 10 20) :s :e "error style")
(clog (+ 10 20) :s :w "warn style")
(clog (+ 10 20) :s :i "info style")
(clog (+ 10 20) :s :d "debug style")
(clog (+ 10 20) "debug style is default")
....

image::clog-2.png[title="Predefined style example", width=550]


#### User-defined style

You can redefine the predefined styles or define your own new style by using
`merge-styles` like this.


[source]
....
(d/merge-styles {:warn "background: #9400D3; color: white"
                 :love "background: #FF1493; color: white"})

(clog (+ 10 20) :style :warn "warn style changed")
(clog (+ 10 20) :style :love "love style")

;; You can style the form directly in string format in any way you want.
(clog (+ 10 20) :style "color:orange; background:blue; font-size: 14pt")
....

image::clog-3.png[title="User-defined style example", width=550]


### `:once` option

If you add `:once` (or `:o` in brief) option after the form, the same evaluated value will
not be printed. This is a very useful feature, when you are debugging a game programming,
where successive multiple frames usually have the same evaluated value.


[source]
....
(def a (atom 10))

;; This will be printed.
(clog @a :once)

;; This will not be printed,
;; because the evaluated value is the same as before.
(clog @a :once)


(reset! a 20)

;; This will be printed,
;; because the evaluated value is not the same as before.
(clog @a :once)

;; This will not be printed,
;; because the evaluated value is the same as before.
(clog @a :once)
....

image::clog-4.png[title=":once option example", width=550]

NOTE: `(:once mode)` string is appended after the form header to remind you of `:once`
  mode.

   
### `:js` option

If `:js` option is added after the form, the JavaScript object will be printed as well, so
you can inspect the internal structures of ClojureScript data types.

....
(clog {:a 10 :b 20} :js)
....

image::clog-5.png[title=":js option example", width=550]


## `break` examples

### `break` options

You can use `break` to set the breakpoint in the source code like this. You can add string
option for message, or `:if` option for conditional break.

[source]
....
(break)
(break "hello world")
(break :if (> 10 20) "this will not be printed")
(break :if (< 10 20) "10 is less than 20")
....

You can see the message in DevTool's console window.

image:break-1.png[title="break examples", width=550]


### Callstack, locals, etc

After setting the breakpoint, you can inspect the callstack, locals, etc. in the browser's
DevTool window.

[source]
....
(defn my-fun2
  [a {:keys [b c d] :or {d 10 b 20 c 30}} [e f g & h]]
  (break)
  (clog [a b c d e f g h]))

(my-fun2 (take 5 (range)) {:c 50 :d 100} ["a" "b" "c" "d" "e"]) 
....

image:break-2.png[]

You can see the message in DevTool's console window.

image:break-3.png[width=550]
  

### `:if` option example
  
When using `break`, you can use `:if` like this.

[source]
....
(defn my-fun3 []
  (let [a 10
        b 20]
    (dotimes [i 1000]
      (break :if (= i 999)))))

(my-fun3)
....

image:break-4.png[]


[#browser-repl]
## Usage in ClojureScript on Browser REPL

You can use both `dbg`/`dbgn` and `clog`/`clogn` on the browser REPL. The following is
an example about running the link:https://github.com/bhauman/lein-figwheel[figwheel].

[source]
.project.clj
....
(defproject example "0.1.0-SNAPSHOT"
  :dependencies [[org.clojure/clojure "1.8.0"]
                 [org.clojure/clojurescript "1.9.854"]
                 [philoskim/debux "0.4.1"]]
  :plugins [[lein-cljsbuild "1.1.6"]
            [lein-figwheel  "0.5.10"]]
  :source-paths ["src/clj"]
  :clean-targets ^{:protect false}
                 ["resources/public/js/app.js"
                  "resources/public/js/app.js.map"]
  :cljsbuild {:builds [{:id "dev"
                        :source-paths ["src/cljs"]
                        :figwheel true
                        :compiler {:main example.core
                                   :asset-path "js/out"
                                   :output-to "resources/public/js/app.js"
                                   :output-dir "resources/public/js/out"
                                   :source-map true
                                   :optimizations :none} }]})
....


And then run figwheel like this on terminal window.


[listing]
----
$ lein figwheel
Figwheel: Cutting some fruit, just a sec ...
Figwheel: Validating the configuration found in project.clj
Figwheel: Configuration Valid :)
Figwheel: Starting server at http://0.0.0.0:3449
Figwheel: Watching build - dev
Compiling "resources/public/js/app.js" from ["src/cljs"]...
Successfully compiled "resources/public/js/app.js" in 2.14 seconds.
Launching ClojureScript REPL for build: dev
Figwheel Controls:
          (stop-autobuild)                ;; stops Figwheel autobuilder
          (start-autobuild [id ...])      ;; starts autobuilder focused on optional ids
          (switch-to-build id ...)        ;; switches autobuilder to different build
          (reset-autobuild)               ;; stops, cleans, and starts autobuilder
          (reload-config)                 ;; reloads build config and resets autobuild
          (build-once [id ...])           ;; builds source one time
          (clean-builds [id ..])          ;; deletes compiled cljs target files
          (print-config [id ...])         ;; prints out build configurations
          (fig-status)                    ;; displays current state of system
          (figwheel.client/set-autoload false)    ;; will turn autoloading off
          (figwheel.client/set-repl-pprint false) ;; will turn pretty printing off
  Switch REPL build focus:
          :cljs/quit                      ;; allows you to switch REPL to another build
    Docs: (doc function-name-here)
    Exit: Control+C or :cljs/quit
 Results: Stored in vars *1, *2, *3, *e holds last exception object
Prompt will show when Figwheel connects to your application
----

After that, connect to `http://localhost:3449` on your browser.

[listing]
----
To quit, type: :cljs/quit
cljs.user=> (require '[debux.cs.core :refer-macros [clog clogn dbg dbgn break]])        
nil
  
cljs.user=> (dbg (+ 1 2))

dbg: (+ 1 2) =>
|   3
3
  
cljs.user=> 
----

Now you can do anything in this browser REPL as in the Clojure REPL. When you evaluate
`dbg`/`dbgn` in your ClojureScript source code, the result will go to both the REPL window
and the browser's console window. When you evaluate `clog`/`clogn` in your ClojureScript
source code, the result will go only to your browser's console window.


## `debux.el` for Emacs CIDER user

Inserting or deleting `dbg`/`dbgn`/`clog`/`clogn` manually is very painful. As Emacs user
I wrote `debux.el` for Emacs CIDER for my convenience. I think it's not perfect but better
than nothing. If you find it useful, append the following `debux.el` (which is in project
root folder) to the `~/.emacs.d/init.el`.


### `debux.el`

Refer to https://github.com/philoskim/debux/blob/master/debux.el[here] for the source code
of `debux.el` .


### How to use

* If you are editing on `\*.clj` or `*.cljc` files, pass:q[`(dbg ...)`] or pass:q[`(dbgn
...)`] will be inserted or deleted.

* If you are editing on `*.cljs` files, pass:q[`(clog ...)`] or pass:q[`(clogn ...)`] will
be inserted or deleted.



#### Inserting pass:q[`dbg`/`clog`] or pass:q[`dbgn`/`clogn`] 

When you double-click the left mouse button on one of the open parentheses and the
following string is not `dbg` or `clog`, it will be inserted.

* The `v` of the following examples marks the cursor position.

[source]
....
;; before
;; v
   (let [a 1 b 2] 
     (+ a b))

;; after
   (dbg (let [a 1 b 2] 
          (+ a b)))
....

When you double-click on a symbol, `dbg` or `clog` will be inserted as well.

[source]
....
;; before
;     v
   (+ a b)

;; after
   (+ (dbg a) b)
....

When you double-click on one of the open parentheses while pressing `<Ctrl>` key and the
following string is not `dbgn` or `clogn`, it will be inserted.

[source]
....
;; before
;; v
   (defn foo [a b c]
     (* a b c))

;; after
   (dbgn (defn foo [a b c]
           (* a b c)))
....


#### Deleting pass:q[`dbg`/`clog`/`dbgn`/`clogn`]

When you double-click on one of the open parentheses and the following string is `dbg`,
`clog`, `dbgn` or `clogn`, it will be deleted.

[source]
....
;; before
;; v
   (dbg (let [a 1 b 2] 
          (+ a b)))

;; after
   (let [a 1 b 2] 
     (+ a b))


;; before
;; v
   (dbgn (defn foo [a b c]
           (* a b c)))

;; after
   (defn foo [a b c]
     (* a b c))
....


## License
Copyright © 2015--2018 Young Tae Kim

Distributed under the Eclipse Public License either version 1.0 or any later version.
